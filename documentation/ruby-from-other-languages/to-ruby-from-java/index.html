---
layout: page
title: To Ruby From Java
---

<p>Java is mature. It&#8217;s tested. And it&#8217;s fast (contrary to what the anti-Java crowd may
still claim). It&#8217;s also quite verbose. Going from Java to Ruby, expect your code size
to shrink down considerably. You can also expect it to take less time to knock together
quick prototypes.</p>


	<h3>Similarities</h3>


As with Java, in Ruby,...
	<ul>
<li>Memory is managed for you via a garbage collector.</li>
		<li>Objects are strongly typed.</li>
		<li>There are public, private, and protected methods.</li>
		<li>There are embedded doc tools (Ruby&#8217;s is called RDoc). The docs generated by rdoc look
very similar to those generated by javadoc.</li>
	</ul>
<h3>Differences</h3>


Unlike Java, in Ruby,...
	<ul>
<li>You don&#8217;t need to compile your code. You just run it directly.</li>
		<li>There are several different popular third-party <span class="caps">GUI</span> toolkits. Ruby users can try
<a href="http://wxruby.rubyforge.org/wiki/wiki.pl">WxRuby</a>,
<a href="http://www.fxruby.org/">FXRuby</a>,
<a href="http://ruby-gnome2.sourceforge.jp/">Ruby-GNOME2</a>,
or the bundled-in Ruby Tk for example.</li>
		<li>You use the <code>end</code> keyword after defining things like classes, instead of having
to put braces around blocks of code.</li>
		<li>You have <code>require</code> instead of <code>import</code>.</li>
		<li>All member variables are private. From the outside, you access everything via methods.</li>
		<li>Parentheses in method calls are usually optional and often omitted.</li>
		<li>Everything is an object, including numbers like 2 and 3.14159.</li>
		<li>There&#8217;s no static type checking.</li>
		<li>Variable names are just labels. They don&#8217;t have a type associated
with them.</li>
		<li>There are no type declarations. You just assign to new variable names as-needed
and they just &#8220;spring up&#8221; (i.e. <code>a = [1,2,3]</code> rather than <code>int[] a = {1,2,3};</code>).</li>
		<li>There&#8217;s no casting. Just call the methods. Your unit tests should tell you
before you even run the code if you&#8217;re going to see an exception.</li>
		<li>It&#8217;s <code>foo = Foo.new( "hi")</code> instead of <code>Foo foo = new Foo( "hi" )</code>.</li>
		<li>The constructor is always named &#8220;initialize&#8221; instead of the name of the class.</li>
		<li>You have &#8220;mixin&#8217;s&#8221; instead of interfaces.</li>
		<li>
<span class="caps">YAML</span> tends to be favored over <span class="caps">XML</span>.</li>
		<li>It&#8217;s <code>nil</code> instead of <code>null</code>.</li>
		<li>
<code>==</code> and <code>equals()</code> are handled differently in Ruby.  Use <code>==</code> when you want to test equivalence in Ruby (<code>equals()</code> is Java).  Use <code>equal?()</code> when you want to know if two objects are the same (<code>==</code> in Java).</li>
	</ul>
<div id="extended">

</div>
            
