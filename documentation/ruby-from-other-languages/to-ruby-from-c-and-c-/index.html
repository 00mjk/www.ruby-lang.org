---
layout: page
title: To Ruby From C and C++
---

<p>It&#8217;s difficult to write a bulleted list describing how your code
will be different in Ruby from C or C++ because it&#8217;s quite a large
difference. One reason is that the Ruby runtime does so much for you.
Ruby seems about as far as you can get from C&#8217;s &#8220;no hidden mechanism&#8221; 
principle&#8212;the whole point of Ruby is to make the human&#8217;s job easier
at the expense of making the runtime shoulder more of the work. Unless
or until you profile your code for optimization, you don&#8217;t need to
care one whit about &#8220;keeping your compiler happy&#8221; when using Ruby.</p>


	<p>That said, for one thing, you can expect your Ruby code to execute
much more slowly than &#8220;equivalent&#8221; C or C++ code. At the same time,
your head will spin at how rapidly you can get a Ruby program up and
running, as well as at how few lines of code it will take to write it.
Ruby is much much simpler than C++&#8212;it will spoil you rotten.</p>


	<p>Ruby is dynamically typed, rather than statically typed&#8212;the
runtime does as much as possible at run-time. For example, you don&#8217;t
need to know what modules your Ruby program will &#8220;link to&#8221; (that is,
load and use) or what methods it will call ahead of time.</p>


	<p>Happily, it turns out that Ruby and C have a healthy symbiotic
relationship. Ruby supports so-called &#8220;extension modules&#8221;. These
are modules that you can use from your Ruby programs (and which,
from the outside, will look and act just like any other Ruby module),
but which are written in C. In this way, you can compartmentalize the
performance-critical parts of your Ruby software, and smelt
those down to pure C.</p>


	<p>And, of course, Ruby itself is written in C.</p>


	<h3>Similarities with C</h3>


As with C, in Ruby,...
	<ul>
<li>You may program procedurally if you like (but it will still
be object-oriented behind the scenes).</li>
		<li>Most of the operators are the same (including the compound
assignment and also bitwise operators). Though, Ruby doesn&#8217;t
have <code>++</code> or <code>--</code>.</li>
		<li>You&#8217;ve got <code>__FILE__</code> and <code>__LINE__</code>.</li>
		<li>You can also have constants, though there&#8217;s no special <code>const</code>
keyword. Const-ness is enforced by a naming convention instead&#8212;
names starting with a capital letter are for constants.</li>
		<li>Strings go in double-quotes.</li>
		<li>Strings are mutable.</li>
		<li>Just like man pages, you can read most docs in your
terminal window&#8212;though using the <code>ri</code> command.</li>
		<li>You&#8217;ve got the same sort of command-line debugger available.</li>
	</ul>
<h3>Similarities with C++</h3>


As with C++, in Ruby,...
	<ul>
<li>You&#8217;ve got mostly the same operators (even <code>::</code>). <code>&lt;&lt;</code> is often used
for appending elements to a list. One note though: with Ruby you never
use <code>-&gt;</code>&#8212;it&#8217;s always just <code>.</code>.</li>
		<li>
<code>public</code>, <code>private</code>, and <code>protected</code> do similar jobs.</li>
		<li>Inheritance syntax is still only one character, but it&#8217;s <code>&lt;</code>
instead of <code>:</code>.</li>
		<li>You may put your code into &#8220;modules&#8221;, similar to how <code>namespace</code>
in C++ is used.</li>
		<li>Exceptions work in a similar manner, though the keyword names have
been changed to protect the innocent.</li>
	</ul>
<h3>Differences from C</h3>


Unlike C, in Ruby,...
	<ul>
<li>Objects are strongly typed (and variable names themselves
have no type at all).</li>
		<li>There&#8217;s no macros or preprocessor. No casts. No pointers
(nor pointer arithmetic). No typedefs, sizeof, nor enums.</li>
		<li>There are no header files. You just define your functions (usually
referred to as &#8220;methods&#8221;) and classes in the main source code files.</li>
		<li>There&#8217;s no <tt>#define</tt>. Just use constants instead.</li>
		<li>As of Ruby 1.8, code is interpreted at run-time rather than compiled to
any sort of machine- or byte-code.</li>
		<li>All variables live on the heap. Further, you don&#8217;t need to free
them yourself&#8212;the garbage collector takes care of that.</li>
		<li>Arguments to methods (i.e. functions) are passed by reference,
not by value.</li>
		<li>It&#8217;s <code>require 'foo'</code> instead of <code>#include &lt;foo&gt;</code> or <code>#include "foo"</code>.</li>
		<li>You cannot drop down to assembly.</li>
		<li>There&#8217;s no semicolon&#8217;s ending lines.</li>
		<li>You go without parentheses for <code>if</code> and <code>while</code> condition expressions.</li>
		<li>Parentheses for method (i.e. function) calls are often optional.</li>
		<li>You don&#8217;t usually use braces&#8212;just end multi-line constructs
(like <code>while</code> loops) with an <code>end</code> keyword.</li>
		<li>The <code>do</code> keyword is for so-called &#8220;blocks&#8221;. There&#8217;s no &#8220;do statement&#8221; 
like in C.</li>
		<li>The term &#8220;block&#8221; means something different. It&#8217;s for a block of
code that you associate with a method call so the method body can
call out to the block while it executes.</li>
		<li>There are no variable declarations. You just assign to new names
on-the-fly when you need them.</li>
		<li>When tested for truth, only <code>false</code> and <code>nil</code> evaluate to a false value.
Everything else is true (including <code>0</code>, <code>0.0</code>, and <code>"0"</code>).</li>
		<li>There is no <code>char</code>&#8212;they are just 1-letter strings.</li>
		<li>Strings don&#8217;t end with a null byte.</li>
		<li>Array literals go in brackets instead of braces.</li>
		<li>Arrays just automatically get bigger when you stuff more elements into them.</li>
		<li>If you add two arrays, you get back a new and bigger array (of
course, allocated on the heap) instead of doing pointer arithmetic.</li>
		<li>More often than not, everything is an expression (that is, things
like <code>while</code> statements actually evaluate to an rvalue).</li>
	</ul>
<h3>Differences from C++</h3>


Unlike C++, in Ruby,...
	<ul>
<li>There&#8217;s no explicit references. That is, in Ruby, every variable
is just an automatically dereferenced name for some object.</li>
		<li>Objects are strongly but <em>dynamically</em> typed. The runtime
discovers <em>at runtime</em> if that method call actually works.</li>
		<li>The &#8220;constructor&#8221; is called <code>initialize</code> instead of the class
name.</li>
		<li>All methods are always virtual.</li>
		<li>&#8220;Class&#8221; (static) variable names always begin with <tt>@@</tt>
(as in <tt>@@total_widgets</tt>).</li>
		<li>You don&#8217;t directly access member variables&#8212;all
access to public member variables (known in Ruby as attributes)
is via methods.</li>
		<li>It&#8217;s <code>self</code> instead of <code>this</code>.</li>
		<li>Some methods end in a &#8217;?&#8217; or a &#8217;!&#8217;. It&#8217;s actually part of the
method name.</li>
		<li>There&#8217;s no multiple inheritance per se. Though Ruby has &#8220;mixins&#8221; 
(i.e. you can &#8220;inherit&#8221; all instance methods of a module).</li>
		<li>There are some enforced case-conventions (ex. class names start
with a capital letter, variables start with a lowercase letter).</li>
		<li>Parentheses for method calls are usually optional.</li>
		<li>You can re-open a class anytime and add more methods.</li>
		<li>There&#8217;s no need of C++ templates (since you can assign any
kind of object to a given variable, and types get figured out
at runtime anyway). No casting either.</li>
		<li>Iteration is done a bit differently.  In Ruby, you don&#8217;t use a separate iterator object
(like <code>vector&lt;T&gt;::const_iterator iter</code>) but instead your objects
may mixin the <code>Enumerator</code> module and just make a method call like <code>my_obj.each</code>.</li>
		<li>There&#8217;s only two container types: <code>Array</code> and <code>Hash</code>.</li>
		<li>There&#8217;s no type conversions. With Ruby though, you&#8217;ll probably find
that they aren&#8217;t necessary.</li>
		<li>Multithreading is built-in, but as of Ruby 1.8 they are &#8220;green threads&#8221; 
(implemented only within the interpreter) as opposed to native threads.</li>
		<li>A unit testing lib comes standard with Ruby.</li>
	</ul>
<div id="extended">

</div>
            
